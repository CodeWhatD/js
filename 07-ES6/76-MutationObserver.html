<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      let count = 1;
      const node = document.createTextNode(String(count));
      const cal = () => {
        console.log("节点发生变化了");
      };
      const muler = new MutationObserver(cal);
      // observe第二个参数为配置项，配置如下
      /*
        childList: true,//观察目标节点的子节点的新增和删除
        subtree: true, //观察目标节点的所有后代节点
        attributes: true, //观察目标节点的属性节点
        attributeOldValue: true,  //在attributes属性已经设为true的前提下, 将发生变化的属性节点之前的属性值记录下来
        attributeFilter:[],//一个属性名数组(不需要指定命名空间),只有该数组中包含的属性名发生变化时才会被观察到,其他名称的属性发生变化后会被忽略想要设置那些删选参数的话
        characterData: true,  //如果目标节点为characterData节点(一种抽象接口,具体可以为文本节点,注释节点,以及处理指令节点)时,也要观察该节点的文本内容是否发生变化
        characterDataOldValue:true,//在characterData属性已经设为true的前提下,将发生变化characterData节点之前的文本内容记录下来(记录到下面MutationRecord对象的oldValue属性中)
      */
      muler.observe(node, { characterData: true });
      node.data = String(count * 2 + 1); // 此时节点文本发生变化回调cal执行
    </script>
  </body>
</html>
